{"ast":null,"code":"import { RequestStatusResponseStatus } from '../agent';\nimport { Certificate, lookupResultToBuffer } from '../certificate';\nimport { toHex } from '../utils/buffer';\nimport * as _strategy from './strategy';\nexport { _strategy as strategy };\nexport { defaultStrategy } from './strategy';\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param strategy A polling strategy.\n * @param request Request for the readState call.\n * @param blsVerify - optional replacement function that verifies the BLS signature of a certificate.\n */\nexport async function pollForResponse(agent, canisterId, requestId, strategy,\n// eslint-disable-next-line\nrequest, blsVerify) {\n  var _a;\n  const path = [new TextEncoder().encode('request_status'), requestId];\n  const currentRequest = request !== null && request !== void 0 ? request : await ((_a = agent.createReadStateRequest) === null || _a === void 0 ? void 0 : _a.call(agent, {\n    paths: [path]\n  }));\n  const state = await agent.readState(canisterId, {\n    paths: [path]\n  }, undefined, currentRequest);\n  if (agent.rootKey == null) throw new Error('Agent root key not initialized before polling');\n  const cert = await Certificate.create({\n    certificate: state.certificate,\n    rootKey: agent.rootKey,\n    canisterId: canisterId,\n    blsVerify\n  });\n  const maybeBuf = lookupResultToBuffer(cert.lookup([...path, new TextEncoder().encode('status')]));\n  let status;\n  if (typeof maybeBuf === 'undefined') {\n    // Missing requestId means we need to wait\n    status = RequestStatusResponseStatus.Unknown;\n  } else {\n    status = new TextDecoder().decode(maybeBuf);\n  }\n  switch (status) {\n    case RequestStatusResponseStatus.Replied:\n      {\n        return {\n          reply: lookupResultToBuffer(cert.lookup([...path, 'reply'])),\n          certificate: cert\n        };\n      }\n    case RequestStatusResponseStatus.Received:\n    case RequestStatusResponseStatus.Unknown:\n    case RequestStatusResponseStatus.Processing:\n      // Execute the polling strategy, then retry.\n      await strategy(canisterId, requestId, status);\n      return pollForResponse(agent, canisterId, requestId, strategy, currentRequest);\n    case RequestStatusResponseStatus.Rejected:\n      {\n        const rejectCode = new Uint8Array(lookupResultToBuffer(cert.lookup([...path, 'reject_code'])))[0];\n        const rejectMessage = new TextDecoder().decode(lookupResultToBuffer(cert.lookup([...path, 'reject_message'])));\n        throw new Error(`Call was rejected:\\n` + `  Request ID: ${toHex(requestId)}\\n` + `  Reject code: ${rejectCode}\\n` + `  Reject text: ${rejectMessage}\\n`);\n      }\n    case RequestStatusResponseStatus.Done:\n      // This is _technically_ not an error, but we still didn't see the `Replied` status so\n      // we don't know the result and cannot decode it.\n      throw new Error(`Call was marked as done but we never saw the reply:\\n` + `  Request ID: ${toHex(requestId)}\\n`);\n  }\n  throw new Error('unreachable');\n}","map":{"version":3,"names":["RequestStatusResponseStatus","Certificate","lookupResultToBuffer","toHex","_strategy","strategy","defaultStrategy","pollForResponse","agent","canisterId","requestId","request","blsVerify","path","TextEncoder","encode","currentRequest","_a","createReadStateRequest","call","paths","state","readState","undefined","rootKey","Error","cert","create","certificate","maybeBuf","lookup","status","Unknown","TextDecoder","decode","Replied","reply","Received","Processing","Rejected","rejectCode","Uint8Array","rejectMessage","Done"],"sources":["/home/jeco/myprojects/icp/hopechain-frontend/node_modules/@dfinity/agent/src/polling/index.ts"],"sourcesContent":["import { Principal } from '@dfinity/principal';\nimport { Agent, RequestStatusResponseStatus } from '../agent';\nimport { Certificate, CreateCertificateOptions, lookupResultToBuffer } from '../certificate';\nimport { RequestId } from '../request_id';\nimport { toHex } from '../utils/buffer';\n\nexport * as strategy from './strategy';\nexport { defaultStrategy } from './strategy';\nexport type PollStrategy = (\n  canisterId: Principal,\n  requestId: RequestId,\n  status: RequestStatusResponseStatus,\n) => Promise<void>;\nexport type PollStrategyFactory = () => PollStrategy;\n\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param strategy A polling strategy.\n * @param request Request for the readState call.\n * @param blsVerify - optional replacement function that verifies the BLS signature of a certificate.\n */\nexport async function pollForResponse(\n  agent: Agent,\n  canisterId: Principal,\n  requestId: RequestId,\n  strategy: PollStrategy,\n  // eslint-disable-next-line\n  request?: any,\n  blsVerify?: CreateCertificateOptions['blsVerify'],\n): Promise<{\n  certificate: Certificate;\n  reply: ArrayBuffer;\n}> {\n  const path = [new TextEncoder().encode('request_status'), requestId];\n  const currentRequest = request ?? (await agent.createReadStateRequest?.({ paths: [path] }));\n  const state = await agent.readState(canisterId, { paths: [path] }, undefined, currentRequest);\n  if (agent.rootKey == null) throw new Error('Agent root key not initialized before polling');\n  const cert = await Certificate.create({\n    certificate: state.certificate,\n    rootKey: agent.rootKey,\n    canisterId: canisterId,\n    blsVerify,\n  });\n\n  const maybeBuf = lookupResultToBuffer(cert.lookup([...path, new TextEncoder().encode('status')]));\n  let status;\n  if (typeof maybeBuf === 'undefined') {\n    // Missing requestId means we need to wait\n    status = RequestStatusResponseStatus.Unknown;\n  } else {\n    status = new TextDecoder().decode(maybeBuf);\n  }\n\n  switch (status) {\n    case RequestStatusResponseStatus.Replied: {\n      return {\n        reply: lookupResultToBuffer(cert.lookup([...path, 'reply']))!,\n        certificate: cert,\n      };\n    }\n\n    case RequestStatusResponseStatus.Received:\n    case RequestStatusResponseStatus.Unknown:\n    case RequestStatusResponseStatus.Processing:\n      // Execute the polling strategy, then retry.\n      await strategy(canisterId, requestId, status);\n      return pollForResponse(agent, canisterId, requestId, strategy, currentRequest);\n\n    case RequestStatusResponseStatus.Rejected: {\n      const rejectCode = new Uint8Array(\n        lookupResultToBuffer(cert.lookup([...path, 'reject_code']))!,\n      )[0];\n      const rejectMessage = new TextDecoder().decode(\n        lookupResultToBuffer(cert.lookup([...path, 'reject_message']))!,\n      );\n      throw new Error(\n        `Call was rejected:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n` +\n          `  Reject code: ${rejectCode}\\n` +\n          `  Reject text: ${rejectMessage}\\n`,\n      );\n    }\n\n    case RequestStatusResponseStatus.Done:\n      // This is _technically_ not an error, but we still didn't see the `Replied` status so\n      // we don't know the result and cannot decode it.\n      throw new Error(\n        `Call was marked as done but we never saw the reply:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n`,\n      );\n  }\n  throw new Error('unreachable');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}