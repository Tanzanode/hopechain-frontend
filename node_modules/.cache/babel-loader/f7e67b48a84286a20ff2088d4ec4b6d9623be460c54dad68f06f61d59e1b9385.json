{"ast":null,"code":"/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// BLS (Barreto-Lynn-Scott) family of pairing-friendly curves.\n// TODO: import { AffinePoint } from './curve.js';\nimport { getMinHashLength, mapHashToField } from './modular.js';\nimport { ensureBytes, memoized } from './utils.js';\n// prettier-ignore\nimport { createHasher } from './hash-to-curve.js';\nimport { weierstrassPoints } from './weierstrass.js';\n// prettier-ignore\nconst _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = BigInt(2),\n  _3n = BigInt(3);\n// Not used with BLS12-381 (no sequential `11` in X). Useful for other curves.\nfunction NAfDecomposition(a) {\n  const res = [];\n  // a>1 because of marker bit\n  for (; a > _1n; a >>= _1n) {\n    if ((a & _1n) === _0n) res.unshift(0);else if ((a & _3n) === _3n) {\n      res.unshift(-1);\n      a += _1n;\n    } else res.unshift(1);\n  }\n  return res;\n}\nexport function bls(CURVE) {\n  // Fields are specific for curve, so for now we'll need to pass them with opts\n  const {\n    Fp,\n    Fr,\n    Fp2,\n    Fp6,\n    Fp12\n  } = CURVE.fields;\n  const BLS_X_IS_NEGATIVE = CURVE.params.xNegative;\n  const TWIST = CURVE.params.twistType;\n  // Point on G1 curve: (x, y)\n  const G1_ = weierstrassPoints({\n    n: Fr.ORDER,\n    ...CURVE.G1\n  });\n  const G1 = Object.assign(G1_, createHasher(G1_.ProjectivePoint, CURVE.G1.mapToCurve, {\n    ...CURVE.htfDefaults,\n    ...CURVE.G1.htfDefaults\n  }));\n  // Point on G2 curve (complex numbers): (x₁, x₂+i), (y₁, y₂+i)\n  const G2_ = weierstrassPoints({\n    n: Fr.ORDER,\n    ...CURVE.G2\n  });\n  const G2 = Object.assign(G2_, createHasher(G2_.ProjectivePoint, CURVE.G2.mapToCurve, {\n    ...CURVE.htfDefaults,\n    ...CURVE.G2.htfDefaults\n  }));\n  // Applies sparse multiplication as line function\n  let lineFunction;\n  if (TWIST === 'multiplicative') {\n    lineFunction = (c0, c1, c2, f, Px, Py) => Fp12.mul014(f, c0, Fp2.mul(c1, Px), Fp2.mul(c2, Py));\n  } else if (TWIST === 'divisive') {\n    // NOTE: it should be [c0, c1, c2], but we use different order here to reduce complexity of\n    // precompute calculations.\n    lineFunction = (c0, c1, c2, f, Px, Py) => Fp12.mul034(f, Fp2.mul(c2, Py), Fp2.mul(c1, Px), c0);\n  } else throw new Error('bls: unknown twist type');\n  const Fp2div2 = Fp2.div(Fp2.ONE, Fp2.mul(Fp2.ONE, _2n));\n  function pointDouble(ell, Rx, Ry, Rz) {\n    const t0 = Fp2.sqr(Ry); // Ry²\n    const t1 = Fp2.sqr(Rz); // Rz²\n    const t2 = Fp2.mulByB(Fp2.mul(t1, _3n)); // 3 * T1 * B\n    const t3 = Fp2.mul(t2, _3n); // 3 * T2\n    const t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz)² - T1 - T0\n    const c0 = Fp2.sub(t2, t0); // T2 - T0 (i)\n    const c1 = Fp2.mul(Fp2.sqr(Rx), _3n); // 3 * Rx²\n    const c2 = Fp2.neg(t4); // -T4 (-h)\n    ell.push([c0, c1, c2]);\n    Rx = Fp2.mul(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), Fp2div2); // ((T0 - T3) * Rx * Ry) / 2\n    Ry = Fp2.sub(Fp2.sqr(Fp2.mul(Fp2.add(t0, t3), Fp2div2)), Fp2.mul(Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2)² - 3 * T2²\n    Rz = Fp2.mul(t0, t4); // T0 * T4\n    return {\n      Rx,\n      Ry,\n      Rz\n    };\n  }\n  function pointAdd(ell, Rx, Ry, Rz, Qx, Qy) {\n    // Addition\n    const t0 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz\n    const t1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz\n    const c0 = Fp2.sub(Fp2.mul(t0, Qx), Fp2.mul(t1, Qy)); // T0 * Qx - T1 * Qy == Ry * Qx  - Rx * Qy\n    const c1 = Fp2.neg(t0); // -T0 == Qy * Rz - Ry\n    const c2 = t1; // == Rx - Qx * Rz\n    ell.push([c0, c1, c2]);\n    const t2 = Fp2.sqr(t1); // T1²\n    const t3 = Fp2.mul(t2, t1); // T2 * T1\n    const t4 = Fp2.mul(t2, Rx); // T2 * Rx\n    const t5 = Fp2.add(Fp2.sub(t3, Fp2.mul(t4, _2n)), Fp2.mul(Fp2.sqr(t0), Rz)); // T3 - 2 * T4 + T0² * Rz\n    Rx = Fp2.mul(t1, t5); // T1 * T5\n    Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4, t5), t0), Fp2.mul(t3, Ry)); // (T4 - T5) * T0 - T3 * Ry\n    Rz = Fp2.mul(Rz, t3); // Rz * T3\n    return {\n      Rx,\n      Ry,\n      Rz\n    };\n  }\n  // Pre-compute coefficients for sparse multiplication\n  // Point addition and point double calculations is reused for coefficients\n  // pointAdd happens only if bit set, so wNAF is reasonable. Unfortunately we cannot combine\n  // add + double in windowed precomputes here, otherwise it would be single op (since X is static)\n  const ATE_NAF = NAfDecomposition(CURVE.params.ateLoopSize);\n  const calcPairingPrecomputes = memoized(point => {\n    const p = point;\n    const {\n      x,\n      y\n    } = p.toAffine();\n    // prettier-ignore\n    const Qx = x,\n      Qy = y,\n      negQy = Fp2.neg(y);\n    // prettier-ignore\n    let Rx = Qx,\n      Ry = Qy,\n      Rz = Fp2.ONE;\n    const ell = [];\n    for (const bit of ATE_NAF) {\n      const cur = [];\n      ({\n        Rx,\n        Ry,\n        Rz\n      } = pointDouble(cur, Rx, Ry, Rz));\n      if (bit) ({\n        Rx,\n        Ry,\n        Rz\n      } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));\n      ell.push(cur);\n    }\n    if (CURVE.postPrecompute) {\n      const last = ell[ell.length - 1];\n      CURVE.postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last));\n    }\n    return ell;\n  });\n  function millerLoopBatch(pairs, withFinalExponent = false) {\n    let f12 = Fp12.ONE;\n    if (pairs.length) {\n      const ellLen = pairs[0][0].length;\n      for (let i = 0; i < ellLen; i++) {\n        f12 = Fp12.sqr(f12); // This allows us to do sqr only one time for all pairings\n        // NOTE: we apply multiple pairings in parallel here\n        for (const [ell, Px, Py] of pairs) {\n          for (const [c0, c1, c2] of ell[i]) f12 = lineFunction(c0, c1, c2, f12, Px, Py);\n        }\n      }\n    }\n    if (BLS_X_IS_NEGATIVE) f12 = Fp12.conjugate(f12);\n    return withFinalExponent ? Fp12.finalExponentiate(f12) : f12;\n  }\n  // Calculates product of multiple pairings\n  // This up to x2 faster than just `map(({g1, g2})=>pairing({g1,g2}))`\n  function pairingBatch(pairs, withFinalExponent = true) {\n    const res = [];\n    // This cache precomputed toAffine for all points\n    G1.ProjectivePoint.normalizeZ(pairs.map(({\n      g1\n    }) => g1));\n    G2.ProjectivePoint.normalizeZ(pairs.map(({\n      g2\n    }) => g2));\n    for (const {\n      g1,\n      g2\n    } of pairs) {\n      if (g1.equals(G1.ProjectivePoint.ZERO) || g2.equals(G2.ProjectivePoint.ZERO)) throw new Error('pairing is not available for ZERO point');\n      // This uses toAffine inside\n      g1.assertValidity();\n      g2.assertValidity();\n      const Qa = g1.toAffine();\n      res.push([calcPairingPrecomputes(g2), Qa.x, Qa.y]);\n    }\n    return millerLoopBatch(res, withFinalExponent);\n  }\n  // Calculates bilinear pairing\n  function pairing(Q, P, withFinalExponent = true) {\n    return pairingBatch([{\n      g1: Q,\n      g2: P\n    }], withFinalExponent);\n  }\n  const utils = {\n    randomPrivateKey: () => {\n      const length = getMinHashLength(Fr.ORDER);\n      return mapHashToField(CURVE.randomBytes(length), Fr.ORDER);\n    },\n    calcPairingPrecomputes\n  };\n  const {\n    ShortSignature\n  } = CURVE.G1;\n  const {\n    Signature\n  } = CURVE.G2;\n  function normP1(point) {\n    return point instanceof G1.ProjectivePoint ? point : G1.ProjectivePoint.fromHex(point);\n  }\n  function normP1Hash(point, htfOpts) {\n    return point instanceof G1.ProjectivePoint ? point : G1.hashToCurve(ensureBytes('point', point), htfOpts);\n  }\n  function normP2(point) {\n    return point instanceof G2.ProjectivePoint ? point : Signature.fromHex(point);\n  }\n  function normP2Hash(point, htfOpts) {\n    return point instanceof G2.ProjectivePoint ? point : G2.hashToCurve(ensureBytes('point', point), htfOpts);\n  }\n  // Multiplies generator (G1) by private key.\n  // P = pk x G\n  function getPublicKey(privateKey) {\n    return G1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\n  }\n  // Multiplies generator (G2) by private key.\n  // P = pk x G\n  function getPublicKeyForShortSignatures(privateKey) {\n    return G2.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\n  }\n  function sign(message, privateKey, htfOpts) {\n    const msgPoint = normP2Hash(message, htfOpts);\n    msgPoint.assertValidity();\n    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\n    if (message instanceof G2.ProjectivePoint) return sigPoint;\n    return Signature.toRawBytes(sigPoint);\n  }\n  function signShortSignature(message, privateKey, htfOpts) {\n    const msgPoint = normP1Hash(message, htfOpts);\n    msgPoint.assertValidity();\n    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\n    if (message instanceof G1.ProjectivePoint) return sigPoint;\n    return ShortSignature.toRawBytes(sigPoint);\n  }\n  // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n  // e(P, H(m)) == e(G, S)\n  function verify(signature, message, publicKey, htfOpts) {\n    const P = normP1(publicKey);\n    const Hm = normP2Hash(message, htfOpts);\n    const G = G1.ProjectivePoint.BASE;\n    const S = normP2(signature);\n    const exp = pairingBatch([{\n      g1: P.negate(),\n      g2: Hm\n    },\n    // ePHM = pairing(P.negate(), Hm, false);\n    {\n      g1: G,\n      g2: S\n    } // eGS = pairing(G, S, false);\n    ]);\n    return Fp12.eql(exp, Fp12.ONE);\n  }\n  // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n  // e(S, G) == e(H(m), P)\n  function verifyShortSignature(signature, message, publicKey, htfOpts) {\n    const P = normP2(publicKey);\n    const Hm = normP1Hash(message, htfOpts);\n    const G = G2.ProjectivePoint.BASE;\n    const S = normP1(signature);\n    const exp = pairingBatch([{\n      g1: Hm,\n      g2: P\n    },\n    // eHmP = pairing(Hm, P, false);\n    {\n      g1: S,\n      g2: G.negate()\n    } // eSG = pairing(S, G.negate(), false);\n    ]);\n    return Fp12.eql(exp, Fp12.ONE);\n  }\n  function aggregatePublicKeys(publicKeys) {\n    if (!publicKeys.length) throw new Error('Expected non-empty array');\n    const agg = publicKeys.map(normP1).reduce((sum, p) => sum.add(p), G1.ProjectivePoint.ZERO);\n    const aggAffine = agg; //.toAffine();\n    if (publicKeys[0] instanceof G1.ProjectivePoint) {\n      aggAffine.assertValidity();\n      return aggAffine;\n    }\n    // toRawBytes ensures point validity\n    return aggAffine.toRawBytes(true);\n  }\n  function aggregateSignatures(signatures) {\n    if (!signatures.length) throw new Error('Expected non-empty array');\n    const agg = signatures.map(normP2).reduce((sum, s) => sum.add(s), G2.ProjectivePoint.ZERO);\n    const aggAffine = agg; //.toAffine();\n    if (signatures[0] instanceof G2.ProjectivePoint) {\n      aggAffine.assertValidity();\n      return aggAffine;\n    }\n    return Signature.toRawBytes(aggAffine);\n  }\n  function aggregateShortSignatures(signatures) {\n    if (!signatures.length) throw new Error('Expected non-empty array');\n    const agg = signatures.map(normP1).reduce((sum, s) => sum.add(s), G1.ProjectivePoint.ZERO);\n    const aggAffine = agg; //.toAffine();\n    if (signatures[0] instanceof G1.ProjectivePoint) {\n      aggAffine.assertValidity();\n      return aggAffine;\n    }\n    return ShortSignature.toRawBytes(aggAffine);\n  }\n  // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407\n  // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))\n  function verifyBatch(signature,\n  // TODO: maybe `{message: G2Hex, publicKey: G1Hex}[]` instead?\n  messages, publicKeys, htfOpts) {\n    if (!messages.length) throw new Error('Expected non-empty messages array');\n    if (publicKeys.length !== messages.length) throw new Error('Pubkey count should equal msg count');\n    const sig = normP2(signature);\n    const nMessages = messages.map(i => normP2Hash(i, htfOpts));\n    const nPublicKeys = publicKeys.map(normP1);\n    // NOTE: this works only for exact same object\n    const messagePubKeyMap = new Map();\n    for (let i = 0; i < nPublicKeys.length; i++) {\n      const pub = nPublicKeys[i];\n      const msg = nMessages[i];\n      let keys = messagePubKeyMap.get(msg);\n      if (keys === undefined) {\n        keys = [];\n        messagePubKeyMap.set(msg, keys);\n      }\n      keys.push(pub);\n    }\n    const paired = [];\n    try {\n      for (const [msg, keys] of messagePubKeyMap) {\n        const groupPublicKey = keys.reduce((acc, msg) => acc.add(msg));\n        paired.push({\n          g1: groupPublicKey,\n          g2: msg\n        });\n      }\n      paired.push({\n        g1: G1.ProjectivePoint.BASE.negate(),\n        g2: sig\n      });\n      return Fp12.eql(pairingBatch(paired), Fp12.ONE);\n    } catch {\n      return false;\n    }\n  }\n  G1.ProjectivePoint.BASE._setWindowSize(4);\n  return {\n    getPublicKey,\n    getPublicKeyForShortSignatures,\n    sign,\n    signShortSignature,\n    verify,\n    verifyBatch,\n    verifyShortSignature,\n    aggregatePublicKeys,\n    aggregateSignatures,\n    aggregateShortSignatures,\n    millerLoopBatch,\n    pairing,\n    pairingBatch,\n    G1,\n    G2,\n    Signature,\n    ShortSignature,\n    fields: {\n      Fr,\n      Fp,\n      Fp2,\n      Fp6,\n      Fp12\n    },\n    params: {\n      ateLoopSize: CURVE.params.ateLoopSize,\n      r: CURVE.params.r,\n      G1b: CURVE.G1.b,\n      G2b: CURVE.G2.b\n    },\n    utils\n  };\n}","map":{"version":3,"names":["getMinHashLength","mapHashToField","ensureBytes","memoized","createHasher","weierstrassPoints","_0n","BigInt","_1n","_2n","_3n","NAfDecomposition","a","res","unshift","bls","CURVE","Fp","Fr","Fp2","Fp6","Fp12","fields","BLS_X_IS_NEGATIVE","params","xNegative","TWIST","twistType","G1_","n","ORDER","G1","Object","assign","ProjectivePoint","mapToCurve","htfDefaults","G2_","G2","lineFunction","c0","c1","c2","f","Px","Py","mul014","mul","mul034","Error","Fp2div2","div","ONE","pointDouble","ell","Rx","Ry","Rz","t0","sqr","t1","t2","mulByB","t3","t4","sub","add","neg","push","pointAdd","Qx","Qy","t5","ATE_NAF","ateLoopSize","calcPairingPrecomputes","point","p","x","y","toAffine","negQy","bit","cur","postPrecompute","last","length","bind","millerLoopBatch","pairs","withFinalExponent","f12","ellLen","i","conjugate","finalExponentiate","pairingBatch","normalizeZ","map","g1","g2","equals","ZERO","assertValidity","Qa","pairing","Q","P","utils","randomPrivateKey","randomBytes","ShortSignature","Signature","normP1","fromHex","normP1Hash","htfOpts","hashToCurve","normP2","normP2Hash","getPublicKey","privateKey","fromPrivateKey","toRawBytes","getPublicKeyForShortSignatures","sign","message","msgPoint","sigPoint","multiply","normPrivateKeyToScalar","signShortSignature","verify","signature","publicKey","Hm","G","BASE","S","exp","negate","eql","verifyShortSignature","aggregatePublicKeys","publicKeys","agg","reduce","sum","aggAffine","aggregateSignatures","signatures","s","aggregateShortSignatures","verifyBatch","messages","sig","nMessages","nPublicKeys","messagePubKeyMap","Map","pub","msg","keys","get","undefined","set","paired","groupPublicKey","acc","_setWindowSize","r","G1b","b","G2b"],"sources":["/home/jeco/myprojects/icp/hopechain-frontend/node_modules/@noble/curves/src/abstract/bls.ts"],"sourcesContent":["/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// BLS (Barreto-Lynn-Scott) family of pairing-friendly curves.\n// TODO: import { AffinePoint } from './curve.js';\nimport { IField, getMinHashLength, mapHashToField } from './modular.js';\nimport { Hex, PrivKey, CHash, ensureBytes, memoized } from './utils.js';\n// prettier-ignore\nimport {\n  MapToCurve, Opts as HTFOpts, H2CPointConstructor, htfBasicOpts,\n  createHasher\n} from './hash-to-curve.js';\nimport {\n  CurvePointsType,\n  ProjPointType as ProjPointType,\n  CurvePointsRes,\n  weierstrassPoints,\n} from './weierstrass.js';\nimport type { Fp2, Fp6, Fp12, Fp2Bls, Fp12Bls } from './tower.js';\n\n/**\n * BLS != BLS.\n * The file implements BLS (Boneh-Lynn-Shacham) signatures.\n * Used in both BLS (Barreto-Lynn-Scott) and BN (Barreto-Naehrig)\n * families of pairing-friendly curves.\n * Consists of two curves: G1 and G2:\n * - G1 is a subgroup of (x, y) E(Fq) over y² = x³ + 4.\n * - G2 is a subgroup of ((x₁, x₂+i), (y₁, y₂+i)) E(Fq²) over y² = x³ + 4(1 + i) where i is √-1\n * - Gt, created by bilinear (ate) pairing e(G1, G2), consists of p-th roots of unity in\n *   Fq^k where k is embedding degree. Only degree 12 is currently supported, 24 is not.\n * Pairing is used to aggregate and verify signatures.\n * There are two main ways to use it:\n * 1. Fp for short private keys, Fp₂ for signatures\n * 2. Fp for short signatures, Fp₂ for private keys\n **/\n\ntype Fp = bigint; // Can be different field?\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n\nexport type TwistType = 'multiplicative' | 'divisive';\n\nexport type ShortSignatureCoder<Fp> = {\n  fromHex(hex: Hex): ProjPointType<Fp>;\n  toRawBytes(point: ProjPointType<Fp>): Uint8Array;\n  toHex(point: ProjPointType<Fp>): string;\n};\n\nexport type SignatureCoder<Fp> = {\n  fromHex(hex: Hex): ProjPointType<Fp>;\n  toRawBytes(point: ProjPointType<Fp>): Uint8Array;\n  toHex(point: ProjPointType<Fp>): string;\n};\n\nexport type CurveType = {\n  G1: Omit<CurvePointsType<Fp>, 'n'> & {\n    ShortSignature: SignatureCoder<Fp>;\n    mapToCurve: MapToCurve<Fp>;\n    htfDefaults: HTFOpts;\n  };\n  G2: Omit<CurvePointsType<Fp2>, 'n'> & {\n    Signature: SignatureCoder<Fp2>;\n    mapToCurve: MapToCurve<Fp2>;\n    htfDefaults: HTFOpts;\n  };\n  fields: {\n    Fp: IField<Fp>;\n    Fr: IField<bigint>;\n    Fp2: Fp2Bls;\n    Fp6: IField<Fp6>;\n    Fp12: Fp12Bls;\n  };\n  params: {\n    // NOTE: MSB is always ignored and used as marker for length,\n    // otherwise leading zeros will be lost.\n    // Can be different from 'X' (seed) param!\n    ateLoopSize: bigint;\n    xNegative: boolean;\n    r: bigint;\n    twistType: TwistType; // BLS12-381: Multiplicative, BN254: Divisive\n  };\n  htfDefaults: HTFOpts;\n  hash: CHash; // Because we need outputLen for DRBG\n  randomBytes: (bytesLength?: number) => Uint8Array;\n  // This is super ugly hack for untwist point in BN254 after miller loop\n  postPrecompute?: (\n    Rx: Fp2,\n    Ry: Fp2,\n    Rz: Fp2,\n    Qx: Fp2,\n    Qy: Fp2,\n    pointAdd: (Rx: Fp2, Ry: Fp2, Rz: Fp2, Qx: Fp2, Qy: Fp2) => { Rx: Fp2; Ry: Fp2; Rz: Fp2 }\n  ) => void;\n};\n\ntype PrecomputeSingle = [Fp2, Fp2, Fp2][];\ntype Precompute = PrecomputeSingle[];\n\nexport type CurveFn = {\n  getPublicKey: (privateKey: PrivKey) => Uint8Array;\n  getPublicKeyForShortSignatures: (privateKey: PrivKey) => Uint8Array;\n  sign: {\n    (message: Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n    (message: ProjPointType<Fp2>, privateKey: PrivKey, htfOpts?: htfBasicOpts): ProjPointType<Fp2>;\n  };\n  signShortSignature: {\n    (message: Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n    (message: ProjPointType<Fp>, privateKey: PrivKey, htfOpts?: htfBasicOpts): ProjPointType<Fp>;\n  };\n  verify: (\n    signature: Hex | ProjPointType<Fp2>,\n    message: Hex | ProjPointType<Fp2>,\n    publicKey: Hex | ProjPointType<Fp>,\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  verifyShortSignature: (\n    signature: Hex | ProjPointType<Fp>,\n    message: Hex | ProjPointType<Fp>,\n    publicKey: Hex | ProjPointType<Fp2>,\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  verifyBatch: (\n    signature: Hex | ProjPointType<Fp2>,\n    messages: (Hex | ProjPointType<Fp2>)[],\n    publicKeys: (Hex | ProjPointType<Fp>)[],\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  aggregatePublicKeys: {\n    (publicKeys: Hex[]): Uint8Array;\n    (publicKeys: ProjPointType<Fp>[]): ProjPointType<Fp>;\n  };\n  aggregateSignatures: {\n    (signatures: Hex[]): Uint8Array;\n    (signatures: ProjPointType<Fp2>[]): ProjPointType<Fp2>;\n  };\n  aggregateShortSignatures: {\n    (signatures: Hex[]): Uint8Array;\n    (signatures: ProjPointType<Fp>[]): ProjPointType<Fp>;\n  };\n  millerLoopBatch: (pairs: [Precompute, Fp, Fp][]) => Fp12;\n  pairing: (P: ProjPointType<Fp>, Q: ProjPointType<Fp2>, withFinalExponent?: boolean) => Fp12;\n  pairingBatch: (\n    pairs: { g1: ProjPointType<Fp>; g2: ProjPointType<Fp2> }[],\n    withFinalExponent?: boolean\n  ) => Fp12;\n  G1: CurvePointsRes<Fp> & ReturnType<typeof createHasher<Fp>>;\n  G2: CurvePointsRes<Fp2> & ReturnType<typeof createHasher<Fp2>>;\n  Signature: SignatureCoder<Fp2>;\n  ShortSignature: ShortSignatureCoder<Fp>;\n  params: {\n    ateLoopSize: bigint;\n    r: bigint;\n    G1b: bigint;\n    G2b: Fp2;\n  };\n  fields: {\n    Fp: IField<Fp>;\n    Fp2: Fp2Bls;\n    Fp6: IField<Fp6>;\n    Fp12: Fp12Bls;\n    Fr: IField<bigint>;\n  };\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    calcPairingPrecomputes: (p: ProjPointType<Fp2>) => Precompute;\n  };\n};\n\n// Not used with BLS12-381 (no sequential `11` in X). Useful for other curves.\nfunction NAfDecomposition(a: bigint) {\n  const res = [];\n  // a>1 because of marker bit\n  for (; a > _1n; a >>= _1n) {\n    if ((a & _1n) === _0n) res.unshift(0);\n    else if ((a & _3n) === _3n) {\n      res.unshift(-1);\n      a += _1n;\n    } else res.unshift(1);\n  }\n  return res;\n}\n\nexport function bls(CURVE: CurveType): CurveFn {\n  // Fields are specific for curve, so for now we'll need to pass them with opts\n  const { Fp, Fr, Fp2, Fp6, Fp12 } = CURVE.fields;\n  const BLS_X_IS_NEGATIVE = CURVE.params.xNegative;\n  const TWIST: TwistType = CURVE.params.twistType;\n  // Point on G1 curve: (x, y)\n  const G1_ = weierstrassPoints({ n: Fr.ORDER, ...CURVE.G1 });\n  const G1 = Object.assign(\n    G1_,\n    createHasher(G1_.ProjectivePoint, CURVE.G1.mapToCurve, {\n      ...CURVE.htfDefaults,\n      ...CURVE.G1.htfDefaults,\n    })\n  );\n  // Point on G2 curve (complex numbers): (x₁, x₂+i), (y₁, y₂+i)\n  const G2_ = weierstrassPoints({ n: Fr.ORDER, ...CURVE.G2 });\n  const G2 = Object.assign(\n    G2_,\n    createHasher(G2_.ProjectivePoint as H2CPointConstructor<Fp2>, CURVE.G2.mapToCurve, {\n      ...CURVE.htfDefaults,\n      ...CURVE.G2.htfDefaults,\n    })\n  );\n  type G1 = typeof G1.ProjectivePoint.BASE;\n  type G2 = typeof G2.ProjectivePoint.BASE;\n\n  // Applies sparse multiplication as line function\n  let lineFunction: (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) => Fp12;\n  if (TWIST === 'multiplicative') {\n    lineFunction = (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) =>\n      Fp12.mul014(f, c0, Fp2.mul(c1, Px), Fp2.mul(c2, Py));\n  } else if (TWIST === 'divisive') {\n    // NOTE: it should be [c0, c1, c2], but we use different order here to reduce complexity of\n    // precompute calculations.\n    lineFunction = (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) =>\n      Fp12.mul034(f, Fp2.mul(c2, Py), Fp2.mul(c1, Px), c0);\n  } else throw new Error('bls: unknown twist type');\n\n  const Fp2div2 = Fp2.div(Fp2.ONE, Fp2.mul(Fp2.ONE, _2n));\n  function pointDouble(ell: PrecomputeSingle, Rx: Fp2, Ry: Fp2, Rz: Fp2) {\n    const t0 = Fp2.sqr(Ry); // Ry²\n    const t1 = Fp2.sqr(Rz); // Rz²\n    const t2 = Fp2.mulByB(Fp2.mul(t1, _3n)); // 3 * T1 * B\n    const t3 = Fp2.mul(t2, _3n); // 3 * T2\n    const t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz)² - T1 - T0\n    const c0 = Fp2.sub(t2, t0); // T2 - T0 (i)\n    const c1 = Fp2.mul(Fp2.sqr(Rx), _3n); // 3 * Rx²\n    const c2 = Fp2.neg(t4); // -T4 (-h)\n\n    ell.push([c0, c1, c2]);\n\n    Rx = Fp2.mul(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), Fp2div2); // ((T0 - T3) * Rx * Ry) / 2\n    Ry = Fp2.sub(Fp2.sqr(Fp2.mul(Fp2.add(t0, t3), Fp2div2)), Fp2.mul(Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2)² - 3 * T2²\n    Rz = Fp2.mul(t0, t4); // T0 * T4\n    return { Rx, Ry, Rz };\n  }\n  function pointAdd(ell: PrecomputeSingle, Rx: Fp2, Ry: Fp2, Rz: Fp2, Qx: Fp2, Qy: Fp2) {\n    // Addition\n    const t0 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz\n    const t1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz\n    const c0 = Fp2.sub(Fp2.mul(t0, Qx), Fp2.mul(t1, Qy)); // T0 * Qx - T1 * Qy == Ry * Qx  - Rx * Qy\n    const c1 = Fp2.neg(t0); // -T0 == Qy * Rz - Ry\n    const c2 = t1; // == Rx - Qx * Rz\n\n    ell.push([c0, c1, c2]);\n\n    const t2 = Fp2.sqr(t1); // T1²\n    const t3 = Fp2.mul(t2, t1); // T2 * T1\n    const t4 = Fp2.mul(t2, Rx); // T2 * Rx\n    const t5 = Fp2.add(Fp2.sub(t3, Fp2.mul(t4, _2n)), Fp2.mul(Fp2.sqr(t0), Rz)); // T3 - 2 * T4 + T0² * Rz\n    Rx = Fp2.mul(t1, t5); // T1 * T5\n    Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4, t5), t0), Fp2.mul(t3, Ry)); // (T4 - T5) * T0 - T3 * Ry\n    Rz = Fp2.mul(Rz, t3); // Rz * T3\n    return { Rx, Ry, Rz };\n  }\n\n  // Pre-compute coefficients for sparse multiplication\n  // Point addition and point double calculations is reused for coefficients\n  // pointAdd happens only if bit set, so wNAF is reasonable. Unfortunately we cannot combine\n  // add + double in windowed precomputes here, otherwise it would be single op (since X is static)\n  const ATE_NAF = NAfDecomposition(CURVE.params.ateLoopSize);\n\n  const calcPairingPrecomputes = memoized((point: G2) => {\n    const p = point;\n    const { x, y } = p.toAffine();\n    // prettier-ignore\n    const Qx = x, Qy = y, negQy = Fp2.neg(y);\n    // prettier-ignore\n    let Rx = Qx, Ry = Qy, Rz = Fp2.ONE;\n    const ell: Precompute = [];\n    for (const bit of ATE_NAF) {\n      const cur: PrecomputeSingle = [];\n      ({ Rx, Ry, Rz } = pointDouble(cur, Rx, Ry, Rz));\n      if (bit) ({ Rx, Ry, Rz } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));\n      ell.push(cur);\n    }\n    if (CURVE.postPrecompute) {\n      const last = ell[ell.length - 1];\n      CURVE.postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last));\n    }\n    return ell;\n  });\n\n  // Main pairing logic is here. Computes product of miller loops + final exponentiate\n  // Applies calculated precomputes\n  type MillerInput = [Precompute, Fp, Fp][];\n  function millerLoopBatch(pairs: MillerInput, withFinalExponent: boolean = false) {\n    let f12 = Fp12.ONE;\n    if (pairs.length) {\n      const ellLen = pairs[0][0].length;\n      for (let i = 0; i < ellLen; i++) {\n        f12 = Fp12.sqr(f12); // This allows us to do sqr only one time for all pairings\n        // NOTE: we apply multiple pairings in parallel here\n        for (const [ell, Px, Py] of pairs) {\n          for (const [c0, c1, c2] of ell[i]) f12 = lineFunction(c0, c1, c2, f12, Px, Py);\n        }\n      }\n    }\n    if (BLS_X_IS_NEGATIVE) f12 = Fp12.conjugate(f12);\n    return withFinalExponent ? Fp12.finalExponentiate(f12) : f12;\n  }\n  type PairingInput = { g1: G1; g2: G2 };\n  // Calculates product of multiple pairings\n  // This up to x2 faster than just `map(({g1, g2})=>pairing({g1,g2}))`\n  function pairingBatch(pairs: PairingInput[], withFinalExponent: boolean = true) {\n    const res: MillerInput = [];\n    // This cache precomputed toAffine for all points\n    G1.ProjectivePoint.normalizeZ(pairs.map(({ g1 }) => g1));\n    G2.ProjectivePoint.normalizeZ(pairs.map(({ g2 }) => g2));\n    for (const { g1, g2 } of pairs) {\n      if (g1.equals(G1.ProjectivePoint.ZERO) || g2.equals(G2.ProjectivePoint.ZERO))\n        throw new Error('pairing is not available for ZERO point');\n      // This uses toAffine inside\n      g1.assertValidity();\n      g2.assertValidity();\n      const Qa = g1.toAffine();\n      res.push([calcPairingPrecomputes(g2), Qa.x, Qa.y]);\n    }\n    return millerLoopBatch(res, withFinalExponent);\n  }\n  // Calculates bilinear pairing\n  function pairing(Q: G1, P: G2, withFinalExponent: boolean = true): Fp12 {\n    return pairingBatch([{ g1: Q, g2: P }], withFinalExponent);\n  }\n\n  const utils = {\n    randomPrivateKey: (): Uint8Array => {\n      const length = getMinHashLength(Fr.ORDER);\n      return mapHashToField(CURVE.randomBytes(length), Fr.ORDER);\n    },\n    calcPairingPrecomputes,\n  };\n\n  const { ShortSignature } = CURVE.G1;\n  const { Signature } = CURVE.G2;\n\n  type G1Hex = Hex | G1;\n  type G2Hex = Hex | G2;\n  function normP1(point: G1Hex): G1 {\n    return point instanceof G1.ProjectivePoint ? (point as G1) : G1.ProjectivePoint.fromHex(point);\n  }\n  function normP1Hash(point: G1Hex, htfOpts?: htfBasicOpts): G1 {\n    return point instanceof G1.ProjectivePoint\n      ? point\n      : (G1.hashToCurve(ensureBytes('point', point), htfOpts) as G1);\n  }\n  function normP2(point: G2Hex): G2 {\n    return point instanceof G2.ProjectivePoint ? point : Signature.fromHex(point);\n  }\n  function normP2Hash(point: G2Hex, htfOpts?: htfBasicOpts): G2 {\n    return point instanceof G2.ProjectivePoint\n      ? point\n      : (G2.hashToCurve(ensureBytes('point', point), htfOpts) as G2);\n  }\n\n  // Multiplies generator (G1) by private key.\n  // P = pk x G\n  function getPublicKey(privateKey: PrivKey): Uint8Array {\n    return G1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\n  }\n\n  // Multiplies generator (G2) by private key.\n  // P = pk x G\n  function getPublicKeyForShortSignatures(privateKey: PrivKey): Uint8Array {\n    return G2.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\n  }\n\n  // Executes `hashToCurve` on the message and then multiplies the result by private key.\n  // S = pk x H(m)\n  function sign(message: Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n  function sign(message: G2, privateKey: PrivKey, htfOpts?: htfBasicOpts): G2;\n  function sign(message: G2Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array | G2 {\n    const msgPoint = normP2Hash(message, htfOpts);\n    msgPoint.assertValidity();\n    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\n    if (message instanceof G2.ProjectivePoint) return sigPoint;\n    return Signature.toRawBytes(sigPoint);\n  }\n\n  function signShortSignature(\n    message: Hex,\n    privateKey: PrivKey,\n    htfOpts?: htfBasicOpts\n  ): Uint8Array;\n  function signShortSignature(message: G1, privateKey: PrivKey, htfOpts?: htfBasicOpts): G1;\n  function signShortSignature(\n    message: G1Hex,\n    privateKey: PrivKey,\n    htfOpts?: htfBasicOpts\n  ): Uint8Array | G1 {\n    const msgPoint = normP1Hash(message, htfOpts);\n    msgPoint.assertValidity();\n    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\n    if (message instanceof G1.ProjectivePoint) return sigPoint;\n    return ShortSignature.toRawBytes(sigPoint);\n  }\n\n  // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n  // e(P, H(m)) == e(G, S)\n  function verify(\n    signature: G2Hex,\n    message: G2Hex,\n    publicKey: G1Hex,\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    const P = normP1(publicKey);\n    const Hm = normP2Hash(message, htfOpts);\n    const G = G1.ProjectivePoint.BASE;\n    const S = normP2(signature);\n    const exp = pairingBatch([\n      { g1: P.negate(), g2: Hm }, // ePHM = pairing(P.negate(), Hm, false);\n      { g1: G, g2: S }, // eGS = pairing(G, S, false);\n    ]);\n    return Fp12.eql(exp, Fp12.ONE);\n  }\n\n  // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n  // e(S, G) == e(H(m), P)\n  function verifyShortSignature(\n    signature: G1Hex,\n    message: G1Hex,\n    publicKey: G2Hex,\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    const P = normP2(publicKey);\n    const Hm = normP1Hash(message, htfOpts);\n    const G = G2.ProjectivePoint.BASE;\n    const S = normP1(signature);\n    const exp = pairingBatch([\n      { g1: Hm, g2: P }, // eHmP = pairing(Hm, P, false);\n      { g1: S, g2: G.negate() }, // eSG = pairing(S, G.negate(), false);\n    ]);\n    return Fp12.eql(exp, Fp12.ONE);\n  }\n\n  // Adds a bunch of public key points together.\n  // pk1 + pk2 + pk3 = pkA\n  function aggregatePublicKeys(publicKeys: Hex[]): Uint8Array;\n  function aggregatePublicKeys(publicKeys: G1[]): G1;\n  function aggregatePublicKeys(publicKeys: G1Hex[]): Uint8Array | G1 {\n    if (!publicKeys.length) throw new Error('Expected non-empty array');\n    const agg = publicKeys.map(normP1).reduce((sum, p) => sum.add(p), G1.ProjectivePoint.ZERO);\n    const aggAffine = agg; //.toAffine();\n    if (publicKeys[0] instanceof G1.ProjectivePoint) {\n      aggAffine.assertValidity();\n      return aggAffine;\n    }\n    // toRawBytes ensures point validity\n    return aggAffine.toRawBytes(true);\n  }\n\n  // Adds a bunch of signature points together.\n  function aggregateSignatures(signatures: Hex[]): Uint8Array;\n  function aggregateSignatures(signatures: G2[]): G2;\n  function aggregateSignatures(signatures: G2Hex[]): Uint8Array | G2 {\n    if (!signatures.length) throw new Error('Expected non-empty array');\n    const agg = signatures.map(normP2).reduce((sum, s) => sum.add(s), G2.ProjectivePoint.ZERO);\n    const aggAffine = agg; //.toAffine();\n    if (signatures[0] instanceof G2.ProjectivePoint) {\n      aggAffine.assertValidity();\n      return aggAffine;\n    }\n    return Signature.toRawBytes(aggAffine);\n  }\n\n  // Adds a bunch of signature points together.\n  function aggregateShortSignatures(signatures: Hex[]): Uint8Array;\n  function aggregateShortSignatures(signatures: G1[]): G1;\n  function aggregateShortSignatures(signatures: G1Hex[]): Uint8Array | G1 {\n    if (!signatures.length) throw new Error('Expected non-empty array');\n    const agg = signatures.map(normP1).reduce((sum, s) => sum.add(s), G1.ProjectivePoint.ZERO);\n    const aggAffine = agg; //.toAffine();\n    if (signatures[0] instanceof G1.ProjectivePoint) {\n      aggAffine.assertValidity();\n      return aggAffine;\n    }\n    return ShortSignature.toRawBytes(aggAffine);\n  }\n\n  // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407\n  // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))\n  function verifyBatch(\n    signature: G2Hex,\n    // TODO: maybe `{message: G2Hex, publicKey: G1Hex}[]` instead?\n    messages: G2Hex[],\n    publicKeys: G1Hex[],\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    if (!messages.length) throw new Error('Expected non-empty messages array');\n    if (publicKeys.length !== messages.length)\n      throw new Error('Pubkey count should equal msg count');\n    const sig = normP2(signature);\n    const nMessages = messages.map((i) => normP2Hash(i, htfOpts));\n    const nPublicKeys = publicKeys.map(normP1);\n    // NOTE: this works only for exact same object\n    const messagePubKeyMap = new Map<G2, G1[]>();\n    for (let i = 0; i < nPublicKeys.length; i++) {\n      const pub = nPublicKeys[i];\n      const msg = nMessages[i];\n      let keys = messagePubKeyMap.get(msg);\n      if (keys === undefined) {\n        keys = [];\n        messagePubKeyMap.set(msg, keys);\n      }\n      keys.push(pub);\n    }\n    const paired = [];\n    try {\n      for (const [msg, keys] of messagePubKeyMap) {\n        const groupPublicKey = keys.reduce((acc, msg) => acc.add(msg));\n        paired.push({ g1: groupPublicKey, g2: msg });\n      }\n      paired.push({ g1: G1.ProjectivePoint.BASE.negate(), g2: sig });\n      return Fp12.eql(pairingBatch(paired), Fp12.ONE);\n    } catch {\n      return false;\n    }\n  }\n\n  G1.ProjectivePoint.BASE._setWindowSize(4);\n\n  return {\n    getPublicKey,\n    getPublicKeyForShortSignatures,\n    sign,\n    signShortSignature,\n    verify,\n    verifyBatch,\n    verifyShortSignature,\n    aggregatePublicKeys,\n    aggregateSignatures,\n    aggregateShortSignatures,\n    millerLoopBatch,\n    pairing,\n    pairingBatch,\n    G1,\n    G2,\n    Signature,\n    ShortSignature,\n    fields: {\n      Fr,\n      Fp,\n      Fp2,\n      Fp6,\n      Fp12,\n    },\n    params: {\n      ateLoopSize: CURVE.params.ateLoopSize,\n      r: CURVE.params.r,\n      G1b: CURVE.G1.b,\n      G2b: CURVE.G2.b,\n    },\n    utils,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}