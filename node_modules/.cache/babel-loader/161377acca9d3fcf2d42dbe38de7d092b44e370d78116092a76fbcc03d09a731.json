{"ast":null,"code":"'use strict';\n\nconst constants = require('./constants');\nconst MT = constants.MT;\nconst SIMPLE = constants.SIMPLE;\nconst SYMS = constants.SYMS;\n\n/**\n * A CBOR Simple Value that does not map onto a known constant.\n */\nclass Simple {\n  /**\n   * Creates an instance of Simple.\n   *\n   * @param {integer} value - the simple value's integer value\n   */\n  constructor(value) {\n    if (typeof value !== 'number') {\n      throw new Error('Invalid Simple type: ' + typeof value);\n    }\n    if (value < 0 || value > 255 || (value | 0) !== value) {\n      throw new Error('value must be a small positive integer: ' + value);\n    }\n    this.value = value;\n  }\n\n  /**\n   * Debug string for simple value\n   *\n   * @returns {string} simple(value)\n   */\n  toString() {\n    return 'simple(' + this.value + ')';\n  }\n\n  /**\n   * Debug string for simple value\n   *\n   * @returns {string} simple(value)\n   */\n  inspect() {\n    return 'simple(' + this.value + ')';\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {cbor.Encoder} gen The generator to push onto\n   * @returns {number}\n   */\n  encodeCBOR(gen) {\n    return gen._pushInt(this.value, MT.SIMPLE_FLOAT);\n  }\n\n  /**\n   * Is the given object a Simple?\n   *\n   * @param {any} obj - object to test\n   * @returns {bool} - is it Simple?\n   */\n  static isSimple(obj) {\n    return obj instanceof Simple;\n  }\n\n  /**\n   * Decode from the CBOR additional information into a JavaScript value.\n   * If the CBOR item has no parent, return a \"safe\" symbol instead of\n   * `null` or `undefined`, so that the value can be passed through a\n   * stream in object mode.\n   *\n   * @param {Number} val - the CBOR additional info to convert\n   * @param {bool} hasParent - Does the CBOR item have a parent?\n   * @returns {(null|undefined|Boolean|Symbol)} - the decoded value\n   */\n  static decode(val, hasParent) {\n    if (hasParent == null) {\n      hasParent = true;\n    }\n    switch (val) {\n      case SIMPLE.FALSE:\n        return false;\n      case SIMPLE.TRUE:\n        return true;\n      case SIMPLE.NULL:\n        if (hasParent) {\n          return null;\n        } else {\n          return SYMS.NULL;\n        }\n      case SIMPLE.UNDEFINED:\n        if (hasParent) {\n          return undefined;\n        } else {\n          return SYMS.UNDEFINED;\n        }\n      case -1:\n        if (!hasParent) {\n          throw new Error('Invalid BREAK');\n        }\n        return SYMS.BREAK;\n      default:\n        return new Simple(val);\n    }\n  }\n}\nmodule.exports = Simple;","map":{"version":3,"names":["constants","require","MT","SIMPLE","SYMS","Simple","constructor","value","Error","toString","inspect","encodeCBOR","gen","_pushInt","SIMPLE_FLOAT","isSimple","obj","decode","val","hasParent","FALSE","TRUE","NULL","UNDEFINED","undefined","BREAK","module","exports"],"sources":["/home/jeco/myprojects/icp/hopechain-frontend/node_modules/borc/src/simple.js"],"sourcesContent":["'use strict'\n\nconst constants = require('./constants')\nconst MT = constants.MT\nconst SIMPLE = constants.SIMPLE\nconst SYMS = constants.SYMS\n\n/**\n * A CBOR Simple Value that does not map onto a known constant.\n */\nclass Simple {\n  /**\n   * Creates an instance of Simple.\n   *\n   * @param {integer} value - the simple value's integer value\n   */\n  constructor (value) {\n    if (typeof value !== 'number') {\n      throw new Error('Invalid Simple type: ' + (typeof value))\n    }\n    if ((value < 0) || (value > 255) || ((value | 0) !== value)) {\n      throw new Error('value must be a small positive integer: ' + value)\n    }\n    this.value = value\n  }\n\n  /**\n   * Debug string for simple value\n   *\n   * @returns {string} simple(value)\n   */\n  toString () {\n    return 'simple(' + this.value + ')'\n  }\n\n  /**\n   * Debug string for simple value\n   *\n   * @returns {string} simple(value)\n   */\n  inspect () {\n    return 'simple(' + this.value + ')'\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {cbor.Encoder} gen The generator to push onto\n   * @returns {number}\n   */\n  encodeCBOR (gen) {\n    return gen._pushInt(this.value, MT.SIMPLE_FLOAT)\n  }\n\n  /**\n   * Is the given object a Simple?\n   *\n   * @param {any} obj - object to test\n   * @returns {bool} - is it Simple?\n   */\n  static isSimple (obj) {\n    return obj instanceof Simple\n  }\n\n  /**\n   * Decode from the CBOR additional information into a JavaScript value.\n   * If the CBOR item has no parent, return a \"safe\" symbol instead of\n   * `null` or `undefined`, so that the value can be passed through a\n   * stream in object mode.\n   *\n   * @param {Number} val - the CBOR additional info to convert\n   * @param {bool} hasParent - Does the CBOR item have a parent?\n   * @returns {(null|undefined|Boolean|Symbol)} - the decoded value\n   */\n  static decode (val, hasParent) {\n    if (hasParent == null) {\n      hasParent = true\n    }\n    switch (val) {\n      case SIMPLE.FALSE:\n        return false\n      case SIMPLE.TRUE:\n        return true\n      case SIMPLE.NULL:\n        if (hasParent) {\n          return null\n        } else {\n          return SYMS.NULL\n        }\n      case SIMPLE.UNDEFINED:\n        if (hasParent) {\n          return undefined\n        } else {\n          return SYMS.UNDEFINED\n        }\n      case -1:\n        if (!hasParent) {\n          throw new Error('Invalid BREAK')\n        }\n        return SYMS.BREAK\n      default:\n        return new Simple(val)\n    }\n  }\n}\n\nmodule.exports = Simple\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,SAAS,GAAGC,OAAO,CAAC,aAAa,CAAC;AACxC,MAAMC,EAAE,GAAGF,SAAS,CAACE,EAAE;AACvB,MAAMC,MAAM,GAAGH,SAAS,CAACG,MAAM;AAC/B,MAAMC,IAAI,GAAGJ,SAAS,CAACI,IAAI;;AAE3B;AACA;AACA;AACA,MAAMC,MAAM,CAAC;EACX;AACF;AACA;AACA;AACA;EACEC,WAAWA,CAAEC,KAAK,EAAE;IAClB,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC7B,MAAM,IAAIC,KAAK,CAAC,uBAAuB,GAAI,OAAOD,KAAM,CAAC;IAC3D;IACA,IAAKA,KAAK,GAAG,CAAC,IAAMA,KAAK,GAAG,GAAI,IAAK,CAACA,KAAK,GAAG,CAAC,MAAMA,KAAM,EAAE;MAC3D,MAAM,IAAIC,KAAK,CAAC,0CAA0C,GAAGD,KAAK,CAAC;IACrE;IACA,IAAI,CAACA,KAAK,GAAGA,KAAK;EACpB;;EAEA;AACF;AACA;AACA;AACA;EACEE,QAAQA,CAAA,EAAI;IACV,OAAO,SAAS,GAAG,IAAI,CAACF,KAAK,GAAG,GAAG;EACrC;;EAEA;AACF;AACA;AACA;AACA;EACEG,OAAOA,CAAA,EAAI;IACT,OAAO,SAAS,GAAG,IAAI,CAACH,KAAK,GAAG,GAAG;EACrC;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEI,UAAUA,CAAEC,GAAG,EAAE;IACf,OAAOA,GAAG,CAACC,QAAQ,CAAC,IAAI,CAACN,KAAK,EAAEL,EAAE,CAACY,YAAY,CAAC;EAClD;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,OAAOC,QAAQA,CAAEC,GAAG,EAAE;IACpB,OAAOA,GAAG,YAAYX,MAAM;EAC9B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOY,MAAMA,CAAEC,GAAG,EAAEC,SAAS,EAAE;IAC7B,IAAIA,SAAS,IAAI,IAAI,EAAE;MACrBA,SAAS,GAAG,IAAI;IAClB;IACA,QAAQD,GAAG;MACT,KAAKf,MAAM,CAACiB,KAAK;QACf,OAAO,KAAK;MACd,KAAKjB,MAAM,CAACkB,IAAI;QACd,OAAO,IAAI;MACb,KAAKlB,MAAM,CAACmB,IAAI;QACd,IAAIH,SAAS,EAAE;UACb,OAAO,IAAI;QACb,CAAC,MAAM;UACL,OAAOf,IAAI,CAACkB,IAAI;QAClB;MACF,KAAKnB,MAAM,CAACoB,SAAS;QACnB,IAAIJ,SAAS,EAAE;UACb,OAAOK,SAAS;QAClB,CAAC,MAAM;UACL,OAAOpB,IAAI,CAACmB,SAAS;QACvB;MACF,KAAK,CAAC,CAAC;QACL,IAAI,CAACJ,SAAS,EAAE;UACd,MAAM,IAAIX,KAAK,CAAC,eAAe,CAAC;QAClC;QACA,OAAOJ,IAAI,CAACqB,KAAK;MACnB;QACE,OAAO,IAAIpB,MAAM,CAACa,GAAG,CAAC;IAC1B;EACF;AACF;AAEAQ,MAAM,CAACC,OAAO,GAAGtB,MAAM","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}