{"ast":null,"code":"'use strict';\n\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\nclass Tagged {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {Number} tag - the number of the tag\n   * @param {any} value - the value inside the tag\n   * @param {Error} err - the error that was thrown parsing the tag, or null\n   */\n  constructor(tag, value, err) {\n    this.tag = tag;\n    this.value = value;\n    this.err = err;\n    if (typeof this.tag !== 'number') {\n      throw new Error('Invalid tag type (' + typeof this.tag + ')');\n    }\n    if (this.tag < 0 || (this.tag | 0) !== this.tag) {\n      throw new Error('Tag must be a positive integer: ' + this.tag);\n    }\n  }\n\n  /**\n   * Convert to a String\n   *\n   * @returns {String} string of the form '1(2)'\n   */\n  toString() {\n    return `${this.tag}(${JSON.stringify(this.value)})`;\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {cbor.Encoder} gen The generator to push onto\n   * @returns {number}\n   */\n  encodeCBOR(gen) {\n    gen._pushTag(this.tag);\n    return gen.pushAny(this.value);\n  }\n\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {Object} converters - keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} - the converted item\n   */\n  convert(converters) {\n    var er, f;\n    f = converters != null ? converters[this.tag] : undefined;\n    if (typeof f !== 'function') {\n      f = Tagged['_tag' + this.tag];\n      if (typeof f !== 'function') {\n        return this;\n      }\n    }\n    try {\n      return f.call(Tagged, this.value);\n    } catch (error) {\n      er = error;\n      this.err = er;\n      return this;\n    }\n  }\n}\nmodule.exports = Tagged;","map":{"version":3,"names":["Tagged","constructor","tag","value","err","Error","toString","JSON","stringify","encodeCBOR","gen","_pushTag","pushAny","convert","converters","er","f","undefined","call","error","module","exports"],"sources":["/home/jeco/myprojects/icp/hopechain-frontend/node_modules/borc/src/tagged.js"],"sourcesContent":["'use strict'\n\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\nclass Tagged {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {Number} tag - the number of the tag\n   * @param {any} value - the value inside the tag\n   * @param {Error} err - the error that was thrown parsing the tag, or null\n   */\n  constructor (tag, value, err) {\n    this.tag = tag\n    this.value = value\n    this.err = err\n    if (typeof this.tag !== 'number') {\n      throw new Error('Invalid tag type (' + (typeof this.tag) + ')')\n    }\n    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {\n      throw new Error('Tag must be a positive integer: ' + this.tag)\n    }\n  }\n\n  /**\n   * Convert to a String\n   *\n   * @returns {String} string of the form '1(2)'\n   */\n  toString () {\n    return `${this.tag}(${JSON.stringify(this.value)})`\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {cbor.Encoder} gen The generator to push onto\n   * @returns {number}\n   */\n  encodeCBOR (gen) {\n    gen._pushTag(this.tag)\n    return gen.pushAny(this.value)\n  }\n\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {Object} converters - keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} - the converted item\n   */\n  convert (converters) {\n    var er, f\n    f = converters != null ? converters[this.tag] : undefined\n    if (typeof f !== 'function') {\n      f = Tagged['_tag' + this.tag]\n      if (typeof f !== 'function') {\n        return this\n      }\n    }\n    try {\n      return f.call(Tagged, this.value)\n    } catch (error) {\n      er = error\n      this.err = er\n      return this\n    }\n  }\n}\n\nmodule.exports = Tagged\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA,MAAMA,MAAM,CAAC;EACX;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,WAAWA,CAAEC,GAAG,EAAEC,KAAK,EAAEC,GAAG,EAAE;IAC5B,IAAI,CAACF,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,GAAG,GAAGA,GAAG;IACd,IAAI,OAAO,IAAI,CAACF,GAAG,KAAK,QAAQ,EAAE;MAChC,MAAM,IAAIG,KAAK,CAAC,oBAAoB,GAAI,OAAO,IAAI,CAACH,GAAI,GAAG,GAAG,CAAC;IACjE;IACA,IAAK,IAAI,CAACA,GAAG,GAAG,CAAC,IAAM,CAAC,IAAI,CAACA,GAAG,GAAG,CAAC,MAAM,IAAI,CAACA,GAAI,EAAE;MACnD,MAAM,IAAIG,KAAK,CAAC,kCAAkC,GAAG,IAAI,CAACH,GAAG,CAAC;IAChE;EACF;;EAEA;AACF;AACA;AACA;AACA;EACEI,QAAQA,CAAA,EAAI;IACV,OAAO,GAAG,IAAI,CAACJ,GAAG,IAAIK,IAAI,CAACC,SAAS,CAAC,IAAI,CAACL,KAAK,CAAC,GAAG;EACrD;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEM,UAAUA,CAAEC,GAAG,EAAE;IACfA,GAAG,CAACC,QAAQ,CAAC,IAAI,CAACT,GAAG,CAAC;IACtB,OAAOQ,GAAG,CAACE,OAAO,CAAC,IAAI,CAACT,KAAK,CAAC;EAChC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEU,OAAOA,CAAEC,UAAU,EAAE;IACnB,IAAIC,EAAE,EAAEC,CAAC;IACTA,CAAC,GAAGF,UAAU,IAAI,IAAI,GAAGA,UAAU,CAAC,IAAI,CAACZ,GAAG,CAAC,GAAGe,SAAS;IACzD,IAAI,OAAOD,CAAC,KAAK,UAAU,EAAE;MAC3BA,CAAC,GAAGhB,MAAM,CAAC,MAAM,GAAG,IAAI,CAACE,GAAG,CAAC;MAC7B,IAAI,OAAOc,CAAC,KAAK,UAAU,EAAE;QAC3B,OAAO,IAAI;MACb;IACF;IACA,IAAI;MACF,OAAOA,CAAC,CAACE,IAAI,CAAClB,MAAM,EAAE,IAAI,CAACG,KAAK,CAAC;IACnC,CAAC,CAAC,OAAOgB,KAAK,EAAE;MACdJ,EAAE,GAAGI,KAAK;MACV,IAAI,CAACf,GAAG,GAAGW,EAAE;MACb,OAAO,IAAI;IACb;EACF;AACF;AAEAK,MAAM,CAACC,OAAO,GAAGrB,MAAM","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}